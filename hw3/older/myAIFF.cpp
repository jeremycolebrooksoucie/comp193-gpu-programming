/************************************************************************** * *   unsigned shortro notes go here * *   things to fix : *   - COMM chunk may not necess come before SSND chunk (examine_next_chunk) *   - extended80 for sample rate hacked (read_comm_info) *   - some places don't do error checking in file input and output *   - break functions unsigned shorto smaller snippets * *   (lots of different chunk types possible - midi, sound loops, markers, *   text, proprietary, instrumentation, detuning, etc. I'm only assumming *   COMM and SSND - one and only one of each required for an aiff file. * *************************************************************************/#include <stdio.h>#include "myAIFF.h"/************************************************************************** * *   constructor :   first six params are in every aiff header * *************************************************************************/AMyAiff::AMyAiff(void){  // stuff in an aiff header  fNumChannels        = 0;  fNumSampleFrames		= 0;  fSampleSize         = 0;  fSampleRate         = 0;  fOffset             = 0;  fBlocksize          = 0;    fHaveComInfo			= FALSE;}/************************************************************************** * *   ScanHeader :   reads in header info from input file and positions file *                   pounsigned shorter at beginning of SSND data. may need to skip over *                   proprietary and irrelevent chunks. * *************************************************************************/unsigned short AMyAiff::ScanHeader(FILE* infp){  unsigned short err=0;    err = GetHeaderInfo(infp);  if(err) return(err);    err = ExamineNextChunk(infp);  while(err==2){ // error only 2 if returned from skipping waste chunk    printf("skipping an irrelevant chunk\n");    err = ExamineNextChunk(infp);  }    if(err){// error should be 0 now//    cout << "something not standard in input file header" << endl;    return(err);  }    err = CheckForInputErrors();  if(err) return(err);    return(0);}/************************************************************************** * *   GetHeaderInfo : reads in specific header stuff & error checks * *************************************************************************/unsigned short AMyAiff::GetHeaderInfo(FILE* fp){  long inNumBytes = 12;  unsigned short err;  char inputBuffer[BUFSIZ];  char *inPtr;  long NumBytesRead;    NumBytesRead = fread(inputBuffer, 1, inNumBytes, fp);  inPtr = inputBuffer;    unsigned short cnt;  unsigned char read_in;  unsigned long chunkID=0;  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    chunkID <<= 8;    chunkID |= read_in;  }    if (chunkID != 0x464f524d){ // reads file descriptor    printf("ERROR READING AIFF HEADER:\n");    printf("not a FORM file - cannot be AIFF then\n");    return (1);  }    unsigned long chunkSize=0;  for(cnt=0; cnt<4; cnt++){   // reads size of this chunk    read_in = (unsigned char) *inPtr++;    chunkSize <<= 8;    chunkSize |= read_in;  }    unsigned long aiffID=0;             // read file type (should be AIFF)  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    aiffID <<= 8;    aiffID |= read_in;  }  if (aiffID != 0x41494646){    printf("ERROR READING AIFF HEADER:\n");    printf("not an AIFF file\n");    return (1);  }    return(0);}/************************************************************************** * *   ExamineNextChunk    :   looks for COMM chunk and then SSND chunk and *                           stores information about them. returns 2 if *                           neither are found, 1 if error, and 0 if both * *************************************************************************/unsigned short AMyAiff::ExamineNextChunk(FILE* fp){  long inNumBytes = 8;  unsigned short err;  char inputBuffer[BUFSIZ];  char *inPtr;  long NumBytesRead;    NumBytesRead = fread(inputBuffer, 1, inNumBytes, fp);  inPtr = inputBuffer;    unsigned short cnt;  unsigned char read_in;  unsigned long chunkID=0;  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    chunkID <<= 8;    chunkID |= read_in;  }    unsigned long chunkSize=0;  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    chunkSize <<= 8;    chunkSize |= read_in;  }    if (chunkID == 0x434f4d4d){ // "COMM" chunk; needed before data read    if(chunkSize != 18){      printf("PROBLEM WITH AIFF FILE:\n");      printf("COMM chunk not specified as 18 bytes\n");      return (1);    }    err=ReadCommInfo(fp);    if(err) return(1);    fHaveComInfo = TRUE;        err = ExamineNextChunk(fp); // recursive; look for SSND    if(err) return(err);  }    else if (chunkID == 0x53534e44){ // "SSND" chunk; has the sound data.    if(fHaveComInfo){      err = ReadSsndInfo(fp);      return(err);    }    else{// need COMM before SSND in my code (but not officially?)      printf("PROBLEM WITH AIFF FILE:\n");      printf("COMM not before SSND in header\n");      return (1);    }  }  else{	// reads in rest of this useless chunk    while(chunkSize > BUFSIZ){      inNumBytes=BUFSIZ;      chunkSize -= BUFSIZ;      NumBytesRead = fread(inputBuffer, 1, inNumBytes, fp);    }    NumBytesRead = fread(inputBuffer, 1, chunkSize, fp);    return(2);  }    return(0);}/************************************************************************** * *   CheckForInputErrors  :  checks that input file won't break program; *                           only 2 track, 44100 samprate, 16 bit sampsize *                           files are allowed. * *************************************************************************/unsigned short AMyAiff::CheckForInputErrors(){  if(fNumChannels != 2 || fSampleRate != 44100 || fSampleSize != 16){    printf("AIFF INPUT FILE PROBLEM:\n");    printf("must be 44100 samprate, 2 track, 16 bit sampsize file\n");    return (1);  }    if(fOffset !=0 ){    printf("AIFF INPUT FILE PROBLEM:\n");    printf("input file has an offset - not allowed\n");    return (1);  }  if(fBlocksize != 0){    printf("AIFF FILE PROBLEM:\n");    printf("input file's blocksize isn't 0 - not allowed\n");    return (1);  }    return(0);}/************************************************************************** * *   ReadCommInfo  : comm info contains num_channels, num_sample_frames, *                   sample_size, and sample_rate. num_sample_frames refers *                   to the number of sample frames IN THE SSND CHUNK. a *                   sample frame groups all channels per sample, e.g. at *                   16 bit sample rate for 6 channels = 96 bit frame * *************************************************************************/unsigned short AMyAiff::ReadCommInfo(FILE* fp){  long inNumBytes = 18;  unsigned short err;  char inputBuffer[BUFSIZ];  char *inPtr;  long NumBytesRead;    NumBytesRead = fread(inputBuffer, 1, inNumBytes, fp);  inPtr = inputBuffer;    unsigned short cnt;  unsigned char read_in;  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    fNumChannels <<= 8;    fNumChannels |= read_in;  }  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    fNumSampleFrames <<= 8;    fNumSampleFrames |= read_in;  }  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    fSampleSize <<= 8;    fSampleSize |= read_in;  }    unsigned short short1=0, short2=0, short3=0, short4=0, short5=0;  //	double_t sampRate;//	double sampleRateConverted=0;//	sampRate.exp = 0;//	sampRate.man[0] = 0;//	sampRate.man[1] = 0;//	sampRate.man[2] = 0;//	sampRate.man[3] = 0;  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    short1 <<= 8;    short1 |= read_in;  }  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    short2 <<= 8;    short2 |= read_in;  }  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    short3 <<= 8;    short3 |= read_in;  }  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    short4 <<= 8;    short4 |= read_in;  }  for(cnt=0; cnt<2; cnt++){    read_in = (unsigned char) *inPtr++;    short5 <<= 8;    short5 |= read_in;  }////	sampRate.exp 	  = short1;//	sampRate.man[0] = short2;//	sampRate.man[1] = short3;//	sampRate.man[2] = short4;//	sampRate.man[3] =	short5;//	sampleRateConverted=x80tod(&sampleRate);////////// wow, what a pain in the ass extended80 is!!//	fSampleRate = sampleRateConverted;    fSampleRate = short2;  return(0);}/************************************************************************** * *   read_ssnd_info  :   first 8 bytes of ssnd chunk are more info * *************************************************************************/unsigned short AMyAiff::ReadSsndInfo(FILE* fp){  long inNumBytes = 8;  unsigned short err;  char inputBuffer[BUFSIZ];  char *inPtr;  long NumBytesRead;    NumBytesRead = fread(inputBuffer, 1, inNumBytes, fp);  inPtr = inputBuffer;    unsigned short cnt;  unsigned char read_in;  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    fOffset <<= 8;    fOffset |= read_in;  }  for(cnt=0; cnt<4; cnt++){    read_in = (unsigned char) *inPtr++;    fBlocksize <<= 8;    fBlocksize |= read_in;  }    return(0);}/************************************************************************** * *   WriteHeader    :    writes header stuff to output file up to beginning *                       of sound data, and stores locations of where the *                       program will need to go back and write file size *                       stuff (impossible to know until program is done). * *************************************************************************unsigned short AMyAiff::WriteHeader(FILE* outfp){  char outputBuffer[BUFSIZ];  unsigned short err;    sprunsigned shortf(outputBuffer, "FORM");  long NumBytesWritten;  long outNumBytes=4;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }  fMarker1 = ftell(outfp); // take marker for length of file    if(fNumChannels == 1)    sprunsigned shortf(outputBuffer, "%c%c%c%cAIFFCOMM%c%c%c%c%c%c",            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x1);  else // 2 tracks    sprunsigned shortf(outputBuffer, "%c%c%c%cAIFFCOMM%c%c%c%c%c%c%c%c%c",            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x2);    outNumBytes = 18;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }  fMarker2 = ftell(outfp); // take marker for num sample frames    sprunsigned shortf(outputBuffer, "%c%c%c%c", 0x0, 0x0, 0x0, 0x0);  outNumBytes=4;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    // sample size = 8 or 16  if(fSampleSize == 8) sprunsigned shortf(outputBuffer, "%c%c", 0x0, 0x8);  else if(fSampleSize == 16) sprunsigned shortf(outputBuffer, "%c%c", 0x0, 0x10);  outNumBytes=2;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    // samprate 22,254 hz or 44,100k  if(fSampleRate == 22254)    sprunsigned shortf(outputBuffer, "%c%c%c%c%c%c%c%c%c%cSSND",            0x40, 0xd, 0xad, 0xdd, 0x17, 0x46, 0x0, 0x0, 0x0, 0x0);  else if(fSampleRate == 44100)    sprunsigned shortf(outputBuffer, "%c%c%c%c%c%c%c%c%c%cSSND",            0x40, 0xe, 0xac, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);    outNumBytes=14;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    fMarker3 = ftell(outfp); // take marker for length of ssnd chunk  sprunsigned shortf(outputBuffer, "%c%c%c%c%c%c%c%c%c%c%c%c",          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);  outNumBytes=12;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }        return(0);}/************************************************************************** * *   WriteLengthInfo   :   sets correct chunk sizes and such for output file * *************************************************************************unsigned short AMyAiff::WriteLengthInfo(FILE* outfp, unsigned long num_bytes){  fseek(outfp, fMarker1, SEEK_SET);    char outputBuffer[BUFSIZ];  sprunsigned shortf(outputBuffer, "%c%c%c%c",          (((46+(num_bytes)) >> 24) & 0xff),          (((46+(num_bytes)) >> 16) & 0xff),          (((46+(num_bytes)) >> 8) & 0xff),          ((46+(num_bytes)) & 0xff));  long outNumBytes = 4;  long NumBytesWritten;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    // num samp frames divided by 2 if 2 tracks:  unsigned short devisor = (fSampleSize/8) * fNumChannels;  fseek(outfp, fMarker2, SEEK_SET);  sprunsigned shortf(outputBuffer, "%c%c%c%c",          (((num_bytes/devisor) >> 24) & 0xff),          (((num_bytes/devisor) >> 16) & 0xff),          (((num_bytes/devisor) >> 8) & 0xff),          ((num_bytes/devisor) & 0xff));  outNumBytes=4;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    // num bytes in ssnd chunk:  fseek(outfp, fMarker3, SEEK_SET);  sprunsigned shortf(outputBuffer, "%c%c%c%c",          ((((num_bytes)+8) >> 24) & 0xff),          ((((num_bytes)+8) >> 16) & 0xff),          ((((num_bytes)+8) >> 8) & 0xff),          (((num_bytes)+8) & 0xff));  outNumBytes=4;  NumBytesWritten = fwrite(&outputBuffer, 1, outNumBytes, outfp);  if(NumBytesWritten != outNumBytes){    cout << "error writing output file header" << endl;    return(1);  }    return(0);} /************************************************************************/